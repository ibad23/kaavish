\section{Functional Requirements}

This section mentions the specific functional requirements of our design system, AI use-case, and features.

\subsection{Design System}

\subsubsection{Figma Integration and Token Management}

\begin{itemize}
    \item \textbf{Figma Integration:}
    The system must connect to Figma via API or MCP to fetch design files, layers, and tokens automatically. This integration ensures real-time design synchronization and eliminates manual file handling.
    \item \textbf{Design Token Extraction:}
    The system should extract and standardize color, typography, spacing, and other design tokens into a standardized \texttt{tokens.json} or \texttt{SCSS} file for consistent design implementation.
    \item \textbf{Design System Enforcement:}
    All generated UI components must strictly follow the organization’s approved design system. Any deviations should be automatically flagged for review.
\end{itemize}

\subsubsection{Component Detection and Frontend Code Generation}

\begin{itemize}
    \item \textbf{Component Recognition \& Mapping:}
    The system must identify reusable components from Figma and map them to existing Angular components or generate new ones where necessary.
    \item \textbf{HTML/CSS Conversion:}
    The system should convert the Figma layer hierarchy into semantic HTML and SCSS code while maintaining layout accuracy within a 2-pixel deviation.
    \item \textbf{Angular Code Generation:}
    Automatically generate Angular component files (\texttt{.ts}, \texttt{.html}, \texttt{.scss}) and register them within the appropriate Angular modules for seamless integration.
\end{itemize}

\subsubsection{AI-Assisted Logic and Backend Generation}

\begin{itemize}
    \item \textbf{AI Logic Generation:}
    Utilize AI models to infer user-interface logic, event handlers, data bindings, and simple validation flows to generate corresponding TypeScript logic automatically.
    \item \textbf{Backend Code Generation:}
    Generate backend components including C\# models, repositories, controllers, and services based on inferred data structures or input from the design.
    \item \textbf{Database Schema Generation:}
    Automatically create SQL scripts or Entity Framework Core migrations from the inferred data models to maintain backend consistency with frontend components.
\end{itemize}

\subsubsection{Project Management and Developer Review}

\begin{itemize}
    \item \textbf{Project Scaffolding:}
    The system should automatically create complete Angular, C\#, and Database projects following standard folder structures and naming conventions.
    \item \textbf{Manual Override \& Review:}
    Provide an interface for developers to review, edit, and approve the generated code before it is finalized, saved, or committed to the repository.
    \item \textbf{Version Control Integration:}
    Integrate with Git version control to track generated files, maintain commit history, and push approved code directly to repositories.
\end{itemize}

\subsubsection{Quality Assurance and Continuous Improvement}

\begin{itemize}
    \item \textbf{Error Handling \& Logging:}
    The system must log all errors during parsing and generation with full context and provide automatic retry options for transient issues.
    \item \textbf{Feedback Loop for AI Improvement:}
    Collect developer feedback on generated outputs and use it to improve future AI model predictions for higher accuracy and consistency.
    \item \textbf{Design System Compliance Validation:}
    Before final export, validate all components against the design system to ensure consistent typography, color tokens, and spacing are applied across the project.
\end{itemize}

\subsection{Knowledge Base (RAG)}

\begin{itemize}
    \item \textbf{Description:} Centralized, searchable repository of Knoccs documents and product data
    \item The system must allow uploading, KNOCCS documentation and product data from different sources (e.g., SharePoint, databases, local files, etc.)
    \item The system must support various file formats.
    \item The system must store all content in a structured repository with version control and metadata.
    \item The system must automatically extract text from documents and segment it into manageable content chunks for embedding.
    \item The system must clean and normalize text before processing.
    \item The system must generate vector embeddings for each content chunk using a selected embedding model.
    \item The embedding process must capture semantic meaning to enable similarity-based retrieval.
    \item The system must allow users to submit natural-language queries.
    \item The system must feed retrieved document content into an AI model.
    \item The system must generate an answer that references the retrieved content.
    \item The generated responses must include citations or links to the original documents.
    \item The system must authenticate users before granting access to the knowledge base.
    \item The system must enforce role-based access control (RBAC) for sensitive documents.
\end{itemize}

\subsection{Knoccs Feature Modules}

\subsubsection{Tag Management}
\begin{itemize}
    \item \textbf{Description:} Create, edit, and assign tags across modules with color tokens.
    \item The system must allow users to create, rename, and delete tags.
    \item The system must allow assigning and unassigning tags to entities across different modules.
    \item When creating or editing a tag, the system must support color tokens for each tag, defined according to the design system.
    \item The system must ensure tags are searchable and filterable within each module.
    \item The system must restrict tag creation or editing based on user roles and permissions.
\end{itemize}

\subsubsection{Macro Management}
\begin{itemize}
    \item \textbf{Description:} Provide a reusable macro composer that enables users to automate repetitive actions and sequences across the platform.
    \item The system must include a visual or form-based interface for composing macros using predefined actions and conditions.
    \item The system must allow users to save, edit, and reuse macros across different modules.
    \item The system must support executing macros manually or automatically based on defined triggers or events.
    \item The system must validate macros before execution to prevent invalid or conflicting actions.
    \item The system must restrict macro creation and editing based on user roles and permissions.
\end{itemize}


\section{Non-functional Requirements}

This section mentions the specific non-functional requirements of our design system, AI use-cases, and Knoccs feature modules.

\subsection{Design System}

\subsubsection{Accuracy and Correctness}
\begin{itemize}
    \item \textbf{Code Correctness:} The generated Angular code must be syntactically correct and compile without errors.
    \item \textbf{Standards Compliance:} All generated code must adhere to the established Knoccs Angular coding standards, including the use of standalone components.
    \item \textbf{Functional Equivalence:} The design pipeline must correctly interpret and generate code for interactivity defined in Figma prototypes (e.g., hover states) and component states (e.g., disabled, error).
    \item \textbf{Consistency (Determinism):} The same Figma component (and its variants) must produce the exact same code structure every time it is processed.
    \item \textbf{Token Accuracy (Target: 95\%):} The generated code must correctly apply the specified color, typography, and spacing tokens from the W3C Style Dictionary pipeline 95\% of the time.
    \item \textbf{Component Mapping Accuracy (Target: 90\%):} The AI must correctly select the corresponding Angular component based on Figma annotations 90\% of the time.
    \item \textbf{Visual Similarity (Target: 80\%):} The generated component's layout, styling, and responsiveness must achieve an 80\% visual match to the Figma design, as measured by automated screenshot comparison.
\end{itemize}

\subsubsection{Developer Experience (DX) \& Usability}
\begin{itemize}
    \item \textbf{Development Efficiency (Target: 70\% Reduction):} The pipeline must achieve a 70\% reduction in development time for new component creation and a significant reduction in design-dev handoff time.
    \item \textbf{Manual Work (Target: 80\%+ Reduction):} Generated code for standard components should be "production-ready" (i.e., pass all tests) with minimal refactoring.
    \item \textbf{Code Readability:} The generated code must be human-readable, well-commented, and follow a logical structure.
    \item \textbf{Automated Documentation:} The pipeline must auto-generate or update a Storybook entry for each new or modified component, pulling descriptions and properties from the Figma component's documentation.
    \item \textbf{Designer Workflow:} The process of "marking" a component for generation must be streamlined using custom Figma annotation widgets to prevent manual errors.
    \item \textbf{Proactive Validation:} The system must include an annotation validation plugin to prevent errors before the pipeline is even run.
    \item \textbf{Developer Onboarding:} The process of consuming the generated code must be clearly documented and require minimal setup.
\end{itemize}

\subsubsection{Performance}
\begin{itemize}
    \item \textbf{Pipeline Performance (Single Component):} The end-to-end translation of a single component (from Figma publish to committed Angular code) should complete in under 90 seconds.
    \item \textbf{Pipeline Performance (Batch Update):} A full "batch" update of the entire design system (e.g., 50 components) should complete in under 30 minutes.
    \item \textbf{Generated Code Performance (Theming):} The runtime theme switching (light/dark mode) must apply theme changes near-instantaneously (e.g., < 100ms) with no flash of unstyled content.
    \item \textbf{Monitoring:} The system must include a performance monitoring dashboard to track generation times and identify bottlenecks.
\end{itemize}

\subsubsection{Scalability and Maintainability}
\begin{itemize}
    \item \textbf{Component Scalability:} The pipeline must be able to support a design system growing to 500+ unique components and variants.
    \item \textbf{Architectural Extensibility:} Adding a new component to the Figma design system and its corresponding generation template must be a documented process that does not require re-architecting the pipeline.
    \item \textbf{AI Modularity:} The system's "AI Agents Layer" (e.g., LangGraph) must be modular, allowing for individual prompts or agents to be updated without breaking the entire generation chain.
    \item \textbf{Testability:} All generated components must be compatible with a Test-Driven Development (TDD) approach.
    \item \textbf{Governance:} The system must include an approval workflow for all Code Connect mappings to ensure quality.
    \item \textbf{Change Management:} A breaking change detection script must run automatically in the CI pipeline to flag any changes to component props or mappings that could break existing implementations.
\end{itemize}

\subsubsection{Security}
\begin{itemize}
    \item \textbf{Access Control (Tokens):} All access to the Figma API and Azure DevOps must use securely stored, read-only (where applicable) authentication tokens.
    \item \textbf{Access Control (Services):} Access to the AI model APIs (Azure OpenAI) must be restricted to authorized team members and services.
    \item \textbf{Code Security:} All generated code must pass a Static Analysis Security Testing (SAST) scan for common vulnerabilities like Cross-Site Scripting (XSS) before being merged.
\end{itemize}

\subsubsection{Compliance}
\begin{itemize}
    \item \textbf{Accessibility Standards:} All generated components must meet WCAG 2.1 AA compliance.
    \item \textbf{ARIA Implementation:} The AI must correctly generate appropriate ARIA (Accessible Rich Internet Applications) roles, states, and properties for complex components (e.g., modals, dropdowns, tabs).
    \item \textbf{Keyboard Navigation:} Keyboard navigation, such as tabbing and arrow keys, must be fully implemented for all interactive components.
    \item \textbf{Linting:} All generated code must pass automated linting checks based on the established Knoccs Angular style guide.
\end{itemize}

\subsubsection{Reliability and Availability}
\begin{itemize}
    \item \textbf{Pipeline Uptime:} The core CI/CD pipeline (Azure DevOps) responsible for token syncing and code generation must have a 99.9\% uptime during working hours.
    \item \textbf{Graceful Failure (AI):} If the AI model fails to translate a component, it must fail gracefully (i.e., not crash the entire pipeline) and provide clear, actionable error logs.
    \item \textbf{Graceful Failure (Sync):} The GitHub Actions workflow for token syncing must have automatic retry logic and a clear notification process in case of repeated failure.
    \item \textbf{AI Performance Monitoring:} The AI Metrics Dashboard must have triggers to alert the team if accuracy drops below the defined targets (e.g., <80\% visual similarity), signaling a need for retraining or prompt adjustment.
\end{itemize}

\subsubsection{Data Integrity and Backup}
\begin{itemize}
    \item \textbf{Single Source of Truth:} The W3C Design Tokens (in JSON format) are the single source of truth. The bidirectional synchronization between Figma and the code repository via GitHub Actions must ensure this integrity.
    \item \textbf{Atomic Transactions:} The design token translation (Style Dictionary) must be atomic. A failure during translation must not result in a partially updated or corrupted set of CSS variables.
    \item \textbf{Data Consistency:} Data integrity is also ensured through consistency by making sure that the translation is deterministic (i.e., the same input always produces the same output).
    \item \textbf{Version Control \& Backup (Code):} All generated code, pipeline configurations, and token definitions must be stored in the project's Git repository, providing full version history and backup.
    \item \textbf{Version Control \& Backup (Design):} The Figma design file itself must utilize Figma's built-in version history, with major milestones explicitly saved and named.
\end{itemize}

\subsection{Knowledge Base (RAG)}

\begin{itemize}
    \item \textbf{Performance:} A search query must return a fully generated answer in under 5 seconds.
    \item \textbf{Accuracy:} The relevance of retrieved documents must be $>$ 90\%. The generated answer must be factually consistent with the source documents.
    \item \textbf{Usability:} The search interface must be as simple to use as a standard search bar.
    \item \textbf{Maintainability:} The system must provide a way to update or delete documents from the vector store when they become outdated.
\end{itemize}

\subsection{Knoccs Feature Modules}

\subsubsection{Tag Management}
\begin{itemize}
    \item \textbf{Performance:} Applying or removing a tag must be reflected in the UI in under 500ms. Searching by tag must return results in under 2 seconds.
    \item \textbf{Usability:} The tag selection interface must be an accessible, type-ahead autocomplete component.
    \item \textbf{Data Integrity:} Deleting a tag must not delete the objects it was applied to. The system should confirm if the tag should be removed from all objects.
    \item \textbf{Security:} Tag creation/deletion must be restricted to administrator roles.
\end{itemize}

\subsubsection{Macro Management}
\begin{itemize}
    \item \textbf{Performance:} A macro's sequence of actions must be fully executed within 2 seconds of the user's click.
    \item \textbf{Usability:} Creating a macro must be a simple, form-based process that does not require coding.
    \item \textbf{Atomic Transactions:} If a macro involves multiple database actions, all actions should succeed or fail together as a single transaction to prevent partial updates.
    \item \textbf{Security:} Users must only be able to execute macros they have permission for, and the macro's actions must respect the user's underlying permissions.
\end{itemize}

\section{External Interfaces}

\subsection{User Interfaces}
This section includes our mockup screens and briefly explains them.

\textbf{AI usecase: RAG chatbot}
\\\\
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/chatbot.png}
    \caption{RAG chatbot}
    \label{fig:rag}
\end{figure}

\textbf{Tag Management}
\\\\
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/tag.png}
    \caption{Tag management}
    \label{fig:tag_srs}
\end{figure}

\textbf{Macro Management}
\\\\
Need to write description here.

\begin{figure}[H]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.5\textwidth]{figures/srs/macro1.png} &
        \includegraphics[width=0.5\textwidth]{figures/srs/macro2.png} \\
        (a) Interface - Part 1 \& (b) Interface - Part 2
    \end{tabular}
    \caption{Feature: Drag-and-drop and Configuration Views}
    \label{fig:macro}
\end{figure}

\section{Use Cases}
This section presents detailed use cases of our system.
Need to defines/describes all our Actors after their respective first use in the use-case diagrams.

\subsection{Design System}
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/Design Use-Case Diagram.jpg}
    \caption{Design Use-Case Diagram}
    \label{fig:design_usecase}
\end{figure}

\subsection{Knowledge Base (RAG)}
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/RAG Use-Case Diagram.jpg}
    \caption{RAG Use-Case Diagram}
    \label{fig:rag_usecase}
\end{figure}

\subsection{Knoccs Feature Modules}

\subsubsection{Tag Management}
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/Tag Use-Case Diagram.jpg}
    \caption{Tag management Use-Case Diagram}
    \label{fig:tag_usecase}
\end{figure}

\subsubsection{Macro Management}
Need to write description here.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/srs/Macro Use-Case Diagram.jpg}
    \caption{Macro management Use-Case Diagram}
    \label{fig:macro_usecase}
\end{figure}

\section{System Diagram}
This diagram represents an integrated workflow combining design, component-based development, and Retrieval Augmented Generation (RAG) all connected through the Knoccs platform. Each module plays a distinct role in automating UI generation and enhancing platform functionality with AI.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{figures/srs/Block Diagram.jpg}
    \caption{System Block Diagram}
    \label{fig:placeholder}
\end{figure}

\subsection{Components}
\begin{itemize}
    \item \textbf{Figma Design System} contains centralized UI/UX components and design tokens for Knoccs. It provides consistent styles, spacing, and components which forms the visual source of truth.
    \item \textbf{Knoccs Codebase} houses the main engineering implementation of the product.
    \item \textbf{Angular Component Library} contains reusable UI elements built for Knoccs. It offers shared, styled components that remain in sync with the design system, ensuring design consistency and reducing duplication across the codebase.
    \item \textbf{Storybook Documentation} provides a visual reference for all components in the system. It auto-syncs with the Component Library and displays component states.
    \item \textbf{RAG + LLM Layer} adds an intelligence engine on top of Knoccs data. It retrieves relevant documents and data through embeddings and vector search, enabling advanced AI assistance.
    \item \textbf{Knoccs Data Sources} contain the system’s entire database including metadata, documents, and other essential information.
    \item \textbf{Claude AI Agents} serve as the automated front-end code generation component. They retrieve all context directly from the Figma MCP Server, understand component structures and constraints, and generate front-end code that matches Knoccs development patterns.
\end{itemize}

\subsection{Interactions}
\begin{itemize}
    \item \textbf{Figma MCP Server} exposes all design artifacts from Figma in a structured machine-readable form. It converts raw design data into a consistent protocol format, enabling tools to fetch live component, layout, and token updates directly from Figma.
    \item \textbf{Figma Code Connect} maps Figma components to framework-ready code definitions and generates code metadata, props, and constraints to provide richer code context for LLMs.
\end{itemize}

% \section{Other Requirements}
% We expect every project to have at least of the following subsections. This section must be aligned with your project deliverables. Please consult with your project supervisor regarding which of the following section(s) you should include in your report

% \section{Datasets}
% This section describes the specific dataset(s) used to build our system. An appropriate snapshot of the dataset(s) is also included. Futher details, when needed, are presented in the appendix.

% \subsection{Application Program Interface (API)}
% This section describes the library or API interface to our system.

% \subsection{Hardware/Communication Interfaces}
% This section describes our project's specific hardware/network interfaces.
