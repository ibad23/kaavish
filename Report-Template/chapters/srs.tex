This chapter provides detailed specifications of the system under development.

\section{Functional Requirements}

% This section describes each function/feature provided by our system. These functions are logically grouped into modules based on their purpose/users/mode of operations etc (as per our system). A functional hierarchy may look like:
% \begin{outline}
%   \1 Module 1:
%   \2 Function 1:
%   \2 Function 2:
%   \3 Sub Function 1
%   \3 Sub Function 2
%   \1 Module 2:
%   \2 Function 1:
%   \2 Function 2:
%   \1 .........
% \end{outline}

% --- The above is to be modified as per your project, e.g. a flat list if your system has limited functional requirements.

This section mentions the specific functional requirements of our design system, AI use-case, and features.
\subsection{Design System}

\subsubsection{Figma Integration and Token Management}

\begin{itemize}
    \item \textbf{Figma Integration:}
    The system must connect to Figma via API or MCP to fetch design files, layers, and tokens automatically. This integration ensures real-time design synchronization and eliminates manual file handling.
    \item \textbf{Design Token Extraction:}
    The system should extract and standardize color, typography, spacing, and other design tokens into a standardized \texttt{tokens.json} or \texttt{SCSS} file for consistent design implementation.
    \item \textbf{Design System Enforcement:}
    All generated UI components must strictly follow the organization’s approved design system. Any deviations should be automatically flagged for review.
\end{itemize}

\subsubsection{Component Detection and Frontend Code Generation}

\begin{itemize}
    \item \textbf{Component Recognition \& Mapping:}
    The system must identify reusable components from Figma and map them to existing Angular components or generate new ones where necessary.
    \item \textbf{HTML/CSS Conversion:}
    The system should convert the Figma layer hierarchy into semantic HTML and SCSS code while maintaining layout accuracy within a 2-pixel deviation.
    \item \textbf{Angular Code Generation:}
    Automatically generate Angular component files (\texttt{.ts}, \texttt{.html}, \texttt{.scss}) and register them within the appropriate Angular modules for seamless integration.
\end{itemize}

\subsubsection{AI-Assisted Logic and Backend Generation}

\begin{itemize}
    \item \textbf{AI Logic Generation:}
    Utilize AI models to infer user-interface logic, event handlers, data bindings, and simple validation flows to generate corresponding TypeScript logic automatically.
    \item \textbf{Backend Code Generation:}
    Generate backend components including C\# models, repositories, controllers, and services based on inferred data structures or input from the design.
    \item \textbf{Database Schema Generation:}
    Automatically create SQL scripts or Entity Framework Core migrations from the inferred data models to maintain backend consistency with frontend components.
\end{itemize}

\subsubsection{Project Management and Developer Review}

\begin{itemize}
    \item \textbf{Project Scaffolding:}
    The system should automatically create complete Angular, C\#, and Database projects following standard folder structures and naming conventions.
    \item \textbf{Manual Override \& Review:}
    Provide an interface for developers to review, edit, and approve the generated code before it is finalized, saved, or committed to the repository.
    \item \textbf{Version Control Integration:}
    Integrate with Git version control to track generated files, maintain commit history, and push approved code directly to repositories.
\end{itemize}

\subsubsection{Quality Assurance and Continuous Improvement}

\begin{itemize}
    \item \textbf{Error Handling \& Logging:}
    The system must log all errors during parsing and generation with full context and provide automatic retry options for transient issues.
    \item \textbf{Feedback Loop for AI Improvement:}
    Collect developer feedback on generated outputs and use it to improve future AI model predictions for higher accuracy and consistency.
    \item \textbf{Design System Compliance Validation:}
    Before final export, validate all components against the design system to ensure consistent typography, color tokens, and spacing are applied across the project.
\end{itemize}

\subsection{AI Use Cases}
\subsubsection{Knowledge Base (RAG)}
\begin{itemize}
    \item \textbf{Description:} Centralized, searchable repository of Knoccs documents and product data
    \item The system must allow uploading, KNOCCS documentation and product data from different sources (e.g., SharePoint, databases, local files, etc.)
    \item The system must support various file formats.
    \item The system must store all content in a structured repository with version control and metadata.
    \item The system must automatically extract text from documents and segment it into manageable content chunks for embedding.
    \item The system must clean and normalize text before processing.
    \item The system must generate vector embeddings for each content chunk using a selected embedding model.
    \item The embedding process must capture semantic meaning to enable similarity-based retrieval.
    \item The system must allow users to submit natural-language queries.
    \item The system must feed retrieved document content into an AI model.
    \item The system must generate an answer that references the retrieved content.
    \item The generated responses must include citations or links to the original documents.
    \item The system must authenticate users before granting access to the knowledge base.
    \item The system must enforce role-based access control (RBAC) for sensitive documents.
\end{itemize}


\subsubsection{KNOCCS Co-Pilot}
    \begin{itemize}
        \item \textbf{{Description:}} AI assistant capable of suggesting configurations, generating workflows, and explaining features.
        \item The system must provide an interactive chat or assistant interface accessible throughout the KNOCCS platform.
        \item The system must accept natural-language instructions to generate or modify workflows (e.g., “Create a workflow for onboarding a new client”).
        \item Connect to the Knowledge Base (RAG) and workflow APIs to provide contextual guidance.
        \item The system must collect feedback on AI responses and use this feedback to fine-tune or retrain
    \end{itemize}
    
\subsubsection{Adaptive AI/Recommendation Agent}
\begin{itemize}
    \item \textbf{Description: }Predictive automation and feature suggestions based on user behavior.
    \item The system must capture and log user interactions (e.g., features accessed, actions taken, frequency of use).
    \item The system must store behavioral data in a structured format suitable for AI model training and inference.
    \item The system must allow administrators to enable or disable behavioral tracking per user or module.
    \item The system must provide personalized feature or workflow suggestions based on recent user behavior.
    \item The system must allow users to accept, ignore, or dismiss recommendations.
    \item The system must log user responses to continuously improve future recommendations.
    \item The system must learn repetitive user actions.
    \item The system must allow users to review and approve any automated actions before execution.
    \item The system must use feedback data to adjust recommendation and improve future predictions.
\end{itemize}

\subsection{Knoccs Feature Modules}
\subsubsection{Workflow Management}
\begin{itemize}
    \item \textbf{Description: }Drag-and-drop workflow builder, trigger/action mapping, and execution engine.
    \item The system must provide a drag-and-drop visual interface for creating and editing workflows.
    \item The system must allow users to be able to draw connections between nodes to define the flow of logic.
    \item The system must support defining triggers (e.g., “on form submission,” “on click)
    \item The system must support mapping actions to triggers  (e.g., "Send Email," "Add Tag).
    \item Users shall be able to save, name, and activate/deactivate workflows.
    \item The system should execute the workflow in real-time when a trigger condition is met.
    \item The system must maintain detailed audit logs for compliance and debugging.
\end{itemize}

\subsubsection{Tag Management}
\begin{itemize}
    \item \textbf{Description:} Create, edit, and assign tags across modules with color tokens.
    \item The system must allow users to create, rename, and delete tags.
    \item The system must allow assigning and unassigning tags to entities across different modules.
    \item When creating or editing a tag, the system must support color tokens for each tag, defined according to the design system.
    \item The system must ensure tags are searchable and filterable within each module.
    \item The system must restrict tag creation or editing based on user roles and permissions.
\end{itemize}


\subsubsection{Notification Management}
\begin{itemize}
    \item \textbf{Description:} Enables automated, consistent communication across email, SMS, and web channels using reusable templates and queued delivery.
    \item The system must include a template builder for creating and managing reusable notification templates (email, SMS, web).
    \item The system must integrate with message queues or job schedulers to handle asynchronous notification delivery.
    \item The web UI shall display real-time notifications to  users.
    \item The system shall allow other modules (e.g., Workflow Management) to trigger notifications.
    \item The system must allow role-based access to template creation, editing, and deletion.
\end{itemize}

\subsubsection{Macro Management}
\begin{itemize}
    \item \textbf{Description:} Provide a reusable macro composer that enables users to automate repetitive actions and sequences across the platform.
    \item The system must include a visual or form-based interface for composing macros using predefined actions and conditions.
    \item The system must allow users to save, edit, and reuse macros across different modules.
    \item The system must support executing macros manually or automatically based on defined triggers or events.
    \item The system must validate macros before execution to prevent invalid or conflicting actions.
    \item The system must restrict macro creation and editing based on user roles and permissions.
\end{itemize}

\subsubsection{Queuing System (Message Broker)}
\begin{itemize}
    \item \textbf{Description:} Integration with RabbitMQ or Kafka for reliable message processing with automatic retry handling and observability.
    \item The system shall be integrated with a message broker (e.g., RabbitMQ)for asynchronous communication between services.
    \item The system must be able to publish and consume messages to/from defined queues.
    \item The system must detect message processing failures and automatically retry delivery based on configurable policies (e.g., retry count, delay).
    \item The system must log all failed message attempts with timestamps and error details.
    \item The system must provide a monitoring dashboard for viewing real-time message flow and errors.
\end{itemize}

\subsubsection{Report Builder}
\begin{itemize}
    \item \textbf{Description:} Enables dynamic report generation with export options (CSV/PDF) and automated scheduling.
    \item The system must allow users to create and configure dynamic reports based on selected data sources, filters, and parameters.
    \item The system must allow users to preview reports before exporting or scheduling them.
    \item The system must allow users to schedule automatic report generation at defined intervals (e.g., daily, weekly, monthly).
    \item Users shall be able to export the report data in different formats (e.g. as a CSV or PDF file).
\end{itemize}

\subsubsection{Webhook Microservice (Rust)}
\begin{itemize}
    \item \textbf{Description:} High-performance webhook handler with automatic retry and analytics capabilities.
    \item The system must provide  secure HTTP endpoints to receive incoming webhook requests from external systems.
    \item The system must validate webhook payloads and authentication headers before processing.
    \item If the queue is unavailable, the service shall implement a local retry mechanism.
    \item The service shall log all incoming requests, their source, and their processing status (e.g., "Accepted," "Failed").
\end{itemize}

% Initial Use Case Diagram
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/use_case.jpeg}
    \caption{High-level use case diagram of the Knoccs system.}
    \label{fig:use_case}
\end{figure}

\section{Non-functional Requirements}

This section mentions the specific non-functional requirements of our design system, AI use-cases, and Knoccs feature modules.

\subsection{Design System}

\subsubsection{Accuracy and Correctness}
\begin{itemize}
    \item \textbf{Code Correctness:} The generated Angular code must be syntactically correct and compile without errors.
    \item \textbf{Standards Compliance:} All generated code must adhere to the established Knoccs Angular coding standards, including the use of standalone components.
    \item \textbf{Functional Equivalence:} The design pipeline must correctly interpret and generate code for interactivity defined in Figma prototypes (e.g., hover states) and component states (e.g., disabled, error).
    \item \textbf{Consistency (Determinism):} The same Figma component (and its variants) must produce the exact same code structure every time it is processed.
    \item \textbf{Token Accuracy (Target: 95\%):} The generated code must correctly apply the specified color, typography, and spacing tokens from the W3C Style Dictionary pipeline 95\% of the time.
    \item \textbf{Component Mapping Accuracy (Target: 90\%):} The AI must correctly select the corresponding Angular component based on Figma annotations 90\% of the time.
    \item \textbf{Visual Similarity (Target: 80\%):} The generated component's layout, styling, and responsiveness must achieve an 80\% visual match to the Figma design, as measured by automated screenshot comparison.
\end{itemize}

\subsubsection{Developer Experience (DX) \& Usability}
\begin{itemize}
    \item \textbf{Development Efficiency (Target: 70\% Reduction):} The pipeline must achieve a 70\% reduction in development time for new component creation and a significant reduction in design-dev handoff time.
    \item \textbf{Manual Work (Target: 80\%+ Reduction):} Generated code for standard components should be "production-ready" (i.e., pass all tests) with minimal refactoring.
    \item \textbf{Code Readability:} The generated code must be human-readable, well-commented, and follow a logical structure.
    \item \textbf{Automated Documentation:} The pipeline must auto-generate or update a Storybook entry for each new or modified component, pulling descriptions and properties from the Figma component's documentation.
    \item \textbf{Designer Workflow:} The process of "marking" a component for generation must be streamlined using custom Figma annotation widgets to prevent manual errors.
    \item \textbf{Proactive Validation:} The system must include an annotation validation plugin to prevent errors before the pipeline is even run.
    \item \textbf{Developer Onboarding:} The process of consuming the generated code must be clearly documented and require minimal setup.
\end{itemize}

\subsubsection{Performance}
\begin{itemize}
    \item \textbf{Pipeline Performance (Single Component):} The end-to-end translation of a single component (from Figma publish to committed Angular code) should complete in under 90 seconds.
    \item \textbf{Pipeline Performance (Batch Update):} A full "batch" update of the entire design system (e.g., 50 components) should complete in under 30 minutes.
    \item \textbf{Generated Code Performance (Theming):} The runtime theme switching (light/dark mode) must apply theme changes near-instantaneously (e.g., < 100ms) with no flash of unstyled content.
    \item \textbf{Monitoring:} The system must include a performance monitoring dashboard to track generation times and identify bottlenecks.
\end{itemize}

\subsubsection{Scalability and Maintainability}
\begin{itemize}
    \item \textbf{Component Scalability:} The pipeline must be able to support a design system growing to 500+ unique components and variants.
    \item \textbf{Architectural Extensibility:} Adding a new component to the Figma design system and its corresponding generation template must be a documented process that does not require re-architecting the pipeline.
    \item \textbf{AI Modularity:} The system's "AI Agents Layer" (e.g., LangGraph) must be modular, allowing for individual prompts or agents to be updated without breaking the entire generation chain.
    \item \textbf{Testability:} All generated components must be compatible with a Test-Driven Development (TDD) approach.
    \item \textbf{Governance:} The system must include an approval workflow for all Code Connect mappings to ensure quality.
    \item \textbf{Change Management:} A breaking change detection script must run automatically in the CI pipeline to flag any changes to component props or mappings that could break existing implementations.
\end{itemize}

\subsubsection{Security}
\begin{itemize}
    \item \textbf{Access Control (Tokens):} All access to the Figma API and Azure DevOps must use securely stored, read-only (where applicable) authentication tokens.
    \item \textbf{Access Control (Services):} Access to the AI model APIs (Azure OpenAI) must be restricted to authorized team members and services.
    \item \textbf{Code Security:} All generated code must pass a Static Analysis Security Testing (SAST) scan for common vulnerabilities like Cross-Site Scripting (XSS) before being merged.
\end{itemize}

\subsubsection{Compliance}
\begin{itemize}
    \item \textbf{Accessibility Standards:} All generated components must meet WCAG 2.1 AA compliance.
    \item \textbf{ARIA Implementation:} The AI must correctly generate appropriate ARIA (Accessible Rich Internet Applications) roles, states, and properties for complex components (e.g., modals, dropdowns, tabs).
    \item \textbf{Keyboard Navigation:} Keyboard navigation, such as tabbing and arrow keys, must be fully implemented for all interactive components.
    \item \textbf{Linting:} All generated code must pass automated linting checks based on the established Knoccs Angular style guide.
\end{itemize}

\subsubsection{Reliability and Availability}
\begin{itemize}
    \item \textbf{Pipeline Uptime:} The core CI/CD pipeline (Azure DevOps) responsible for token syncing and code generation must have a 99.9\% uptime during working hours.
    \item \textbf{Graceful Failure (AI):} If the AI model fails to translate a component, it must fail gracefully (i.e., not crash the entire pipeline) and provide clear, actionable error logs.
    \item \textbf{Graceful Failure (Sync):} The GitHub Actions workflow for token syncing must have automatic retry logic and a clear notification process in case of repeated failure.
    \item \textbf{AI Performance Monitoring:} The AI Metrics Dashboard must have triggers to alert the team if accuracy drops below the defined targets (e.g., <80\% visual similarity), signaling a need for retraining or prompt adjustment.
\end{itemize}

\subsubsection{Data Integrity and Backup}
\begin{itemize}
    \item \textbf{Single Source of Truth:} The W3C Design Tokens (in JSON format) are the single source of truth. The bidirectional synchronization between Figma and the code repository via GitHub Actions must ensure this integrity.
    \item \textbf{Atomic Transactions:} The design token translation (Style Dictionary) must be atomic. A failure during translation must not result in a partially updated or corrupted set of CSS variables.
    \item \textbf{Data Consistency:} Data integrity is also ensured through consistency by making sure that the translation is deterministic (i.e., the same input always produces the same output).
    \item \textbf{Version Control \& Backup (Code):} All generated code, pipeline configurations, and token definitions must be stored in the project's Git repository, providing full version history and backup.
    \item \textbf{Version Control \& Backup (Design):} The Figma design file itself must utilize Figma's built-in version history, with major milestones explicitly saved and named.
\end{itemize}

\subsection{AI Use Cases}

\subsubsection{Knowledge Base (RAG)}
\begin{itemize}
    \item \textbf{Performance:} A search query must return a fully generated answer in under 5 seconds.
    \item \textbf{Accuracy:} The relevance of retrieved documents must be $>$ 90\%. The generated answer must be factually consistent with the source documents.
    \item \textbf{Usability:} The search interface must be as simple to use as a standard search bar.
    \item \textbf{Maintainability:} The system must provide a way to update or delete documents from the vector store when they become outdated.
\end{itemize}

\subsubsection{KNOCCS Co-Pilot}
\begin{itemize}
    \item \textbf{Performance:} Conversational responses must be streamed to the user, with the first token appearing in $<$ 1 second.
    \item \textbf{Accuracy:} Generated workflow configurations must be 100\% syntactically correct and logically valid. Explanations must be factually accurate.
    \item \textbf{Security:} The Co-Pilot must not perform any action without explicit user confirmation. It must adhere to the user's existing permissions.
    \item \textbf{Usability:} The Co-Pilot's language must be clear, helpful, and non-intrusive.
\end{itemize}

\subsubsection{Adaptive AI/Recommendation Agent}
\begin{itemize}
    \item \textbf{Performance:} Pattern analysis must run as a background batch process and must not impact real-time application performance.
    \item \textbf{Usability:} Suggestions must be highly relevant. The system must not overwhelm the user with low-quality or "spam" suggestions (e.g., max 1-2 suggestions per day).
    \item \textbf{Privacy/Compliance:} All behavior tracking must be clearly disclosed in the privacy policy and be compliant with data privacy regulations (e.g., GDPR). Users must be able to opt out.
    \item \textbf{Explainability:} A suggestion should be able to explain \textit{why} it is being made (e.g., "I noticed you performed this action 10 times today").
\end{itemize}

\subsection{Knoccs Feature Modules}

\subsubsection{Workflow Management}
\begin{itemize}
    \item \textbf{Performance:} A workflow must be triggered within 1 second of the event occurring. The visual builder must load in under 3 seconds.
    \item \textbf{Usability:} The drag-and-drop interface must be intuitive, requiring minimal training for a non-technical user.
    \item \textbf{Reliability:} The execution engine must guarantee "at-least-once" execution for all actions. A failure in one action should trigger a defined error-handling path (e.g., retry, log error).
    \item \textbf{Scalability:} The system must be able to process 1,000+ workflow executions per minute.
    \item \textbf{Compliance:} All components used must be WCAG 2.1 AA compliant.
\end{itemize}

\subsubsection{Tag Management}
\begin{itemize}
    \item \textbf{Performance:} Applying or removing a tag must be reflected in the UI in under 500ms. Searching by tag must return results in under 2 seconds.
    \item \textbf{Usability:} The tag selection interface must be an accessible, type-ahead autocomplete component.
    \item \textbf{Data Integrity:} Deleting a tag must not delete the objects it was applied to. The system should confirm if the tag should be removed from all objects.
    \item \textbf{Security:} Tag creation/deletion must be restricted to administrator roles.
\end{itemize}

\subsubsection{Notification Management}
\begin{itemize}
    \item \textbf{Reliability:} The notification system must ensure "at-least-once" delivery via the queue. A failure in an external gateway (e.g., SMS provider) must be logged and retried.
    \item \textbf{Performance:} Web notifications must appear to the user in under 1 second. Asynchronous notifications (Email, SMS) must be sent from the queue within 60 seconds.
    \item \textbf{Scalability:} The system must be able to queue and process 10,000+ notifications per hour.
    \item \textbf{Security:} All templates must be sanitized to prevent XSS vulnerabilities from dynamic variables.
\end{itemize}

\subsubsection{Macro Management}
\begin{itemize}
    \item \textbf{Performance:} A macro's sequence of actions must be fully executed within 2 seconds of the user's click.
    \item \textbf{Usability:} Creating a macro must be a simple, form-based process that does not require coding.
    \item \textbf{Atomic Transactions:} If a macro involves multiple database actions, all actions should succeed or fail together as a single transaction to prevent partial updates.
    \item \textbf{Security:} Users must only be able to execute macros they have permission for, and the macro's actions must respect the user's underlying permissions.
\end{itemize}

\subsubsection{Queuing System (Message Broker)}
\begin{itemize}
    \item \textbf{Reliability:} The system must guarantee "at-least-once" delivery. Messages must be persisted to disk to survive a broker restart.
    \item \textbf{Performance:} The broker must support a throughput of at least 1,000 messages/second.
    \item \textbf{Scalability:} The consumer services must be horizontally scalable (e.g., running in multiple containers) to handle increased load.
    \item \textbf{Maintainability:} Adding a new queue and message type must be a documented process.
\end{itemize}

\subsubsection{Report Builder}
\begin{itemize}
    \item \textbf{Performance:} Simple reports must load in under 5 seconds. Complex reports (e.g., $>$ 10,000 rows) must be processed asynchronously, and the user notified when the report is ready.
    \item \textbf{Security:} Users must only be able to build reports based on data they have permission to access.
    \item \textbf{Data Integrity:} Report data must be a consistent snapshot of the database at the time of execution.
    \item \textbf{Usability:} The report builder interface must be intuitive for non-technical users.
\end{itemize}

\subsubsection{Webhook Microservice (Rust)}
\begin{itemize}
    \item \textbf{Performance:} The service must have a p99 response time of $>$ 50ms for accepting and queueing a payload.
    \item \textbf{Scalability:} Services must be lightweight and able to handle 10,000+ requests per second (RPS).
    \item \textbf{Reliability:} The service must have 99.99\% uptime. It must not lose any incoming data.
    \item \textbf{Security:} The service must validate incoming payloads (e.g., via a shared secret or HMAC signature) to prevent malicious requests.
\end{itemize}


% \section{External Interfaces}

% We expect every project to have at least of the following subsections. This section must be aligned with your project deliverables. Please consult with your project supervisor regarding which of the following section(s) you should include in your report

% \subsection{User Interfaces}
% This section includes our mockup screens and briefly explains them.

% \subsection{Application Program Interface (API)}
% This section describes the library or API interface to our system.

% \subsection{Hardware/Communication Interfaces}
% This section describes our project's specific hardware/network interfaces.

% \section{Use Cases}
% This section presents detailed use cases of our system.

% \section{Datasets}
% This section describes the specific dataset(s) used to build our system. An appropriate snapshot of the dataset(s) is also included. Futher details, when needed, are presented in the appendix.

% \section{System Diagram}
% This diagram gives a high-level view of the different components of our system and the interactions between them. Each component and the particular tools/technologies/libraries used to build it are described.